# MLM 등급 계산 규칙 상세 설명서

## 1. 기본 원칙

MLM 시스템의 등급은 **이진 트리(Binary Tree)** 구조에서 각 노드의 **하위 전체 서브트리 구조**를 기반으로 결정됩니다.

### 핵심 규칙:
- **나를 기준으로 좌우가 나뉨**: 각 노드는 최대 2개의 자식(좌, 우)을 가질 수 있음
- **등급은 하위 전체 구조를 반영**: 직계 자식뿐만 아니라 전체 하위 트리의 구조가 등급을 결정
- **상향식 계산**: 리프 노드부터 시작하여 루트까지 등급을 계산

## 2. 등급별 정의

### F1 등급
- **조건**: 자식이 없거나 한 명만 있는 경우
- **설명**: 리프 노드 또는 불완전한 노드

### F2 등급
- **조건**: 좌우 자식이 모두 있는 경우 (자식들의 등급과 무관)
- **설명**: 완전한 이진 노드의 기본 등급

### F3 등급
- **조건**: 좌우 서브트리에 각각 최소 1개의 F2 등급이 있는 경우
- **설명**: F2를 좌우에 각각 1개씩 포함하는 노드

### F4 등급
- **조건**: 좌우 서브트리에 각각 최소 1개의 F3 등급이 있는 경우
- **설명**: F3를 좌우에 각각 1개씩 포함하는 노드

### F5 등급
- **조건**: 좌우 서브트리의 F4 등급이 1:2 또는 2:1 비율인 경우
- **설명**: F4를 총 3개 가지되, 한쪽에 1개, 다른 쪽에 2개

### F6 등급
- **조건**: 좌우 서브트리의 F5 등급이 1:2 또는 2:1 비율인 경우
- **설명**: F5를 총 3개 가지되, 한쪽에 1개, 다른 쪽에 2개

### F7 등급
- **조건**: 좌우 서브트리의 F6 등급이 1:2 또는 2:1 비율인 경우
- **설명**: F6를 총 3개 가지되, 한쪽에 1개, 다른 쪽에 2개

### F8 등급
- **조건**: 좌우 서브트리의 F7 등급이 1:2 또는 2:1 비율인 경우
- **설명**: F7를 총 3개 가지되, 한쪽에 1개, 다른 쪽에 2개

## 3. 21노드 완전 이진 트리 예시

### 트리 구조 (노드 번호)
```
                    1 (F4)
                  /        \
              2 (F3)       3 (F3)
             /    \        /    \
          4(F2)  5(F2)   6(F2)  7(F3)
         /  \    /  \    /  \    /  \
       8(F1) 9(F1) 10(F1) 11(F1) 12(F1) 13(F1) 14(F2) 15(F2)
                                          /  \    /  \
                                       16(F1) 17(F1) 18(F2) 19(F1)
                                                    /  \
                                                  20(F1) 21(F1)
```

### 등급 계산 과정 (하향식 설명)

#### 레벨 4-5 (리프 노드들)
- 노드 8, 9, 10, 11, 12, 13, 16, 17, 19, 20, 21: **F1** (자식 없음) = 11개

#### 레벨 3-4
- 노드 14: 좌(16) 우(17) 자식 있음 → **F2**
- 노드 18: 좌(20) 우(21) 자식 있음 → **F2**
- 노드 15: 좌(18) 우(19) 자식 있음, 18이 F2 → 좌 서브트리에 F2 1개 → **F2**

#### 레벨 2
- 노드 4: 좌(8) 우(9) 자식 있음, 둘 다 F1 → **F2**
- 노드 5: 좌(10) 우(11) 자식 있음, 둘 다 F1 → **F2**
- 노드 6: 좌(12) 우(13) 자식 있음, 둘 다 F1 → **F2**
- 노드 7: 좌(14-F2) 우(15-F2) 자식 있음
  - 좌 서브트리에 F2(14) 1개
  - 우 서브트리에 F2(15,18) 2개 (15의 하위에 18도 F2)
  - 좌우에 F2가 각각 있음 → **F3**

#### 레벨 1
- 노드 2: 좌(4-F2) 우(5-F2) 자식 있음
  - 좌 서브트리에 F2(4) 1개
  - 우 서브트리에 F2(5) 1개
  - 좌우에 F2가 각 1개씩 → **F3**

- 노드 3: 좌(6-F2) 우(7-F3) 자식 있음
  - 좌 서브트리에 F2(6) 1개
  - 우 서브트리에 F2(14,15,18) 3개, F3(7) 1개
  - 좌우에 F2가 각각 있음 → **F3**

#### 레벨 0 (루트)
- 노드 1: 좌(2-F3) 우(3-F3) 자식 있음
  - 좌 서브트리에 F3(2) 1개
  - 우 서브트리에 F3(3,7) 2개
  - 좌우에 F3가 각 1개 이상 → **F4**

### 최종 등급 분포
- **F1**: 11명 (노드 8, 9, 10, 11, 12, 13, 16, 17, 19, 20, 21)
- **F2**: 6명 (노드 4, 5, 6, 14, 15, 18)
- **F3**: 3명 (노드 2, 3, 7)
- **F4**: 1명 (노드 1)

## 4. 구현 알고리즘

```javascript
async function calculateGrade(userId) {
  const user = await User.findOne({ loginId: userId });
  if (!user) return 'F1';

  // 자식 확인
  const leftChild = await User.findOne({ parentId: userId, position: 'L' });
  const rightChild = await User.findOne({ parentId: userId, position: 'R' });

  // F1: 자식이 없거나 한 명만 있는 경우
  if (!leftChild || !rightChild) {
    return 'F1';
  }

  // 좌우 서브트리의 모든 등급 수집
  const leftGrades = await collectSubtreeGrades(leftChild.loginId);
  const rightGrades = await collectSubtreeGrades(rightChild.loginId);

  // F2 체크: 좌우 자식이 모두 있고, F2가 좌우에 각 1개 이상
  if (leftGrades.F2 >= 1 && rightGrades.F2 >= 1) {
    // F3 체크: F3가 좌우에 각 1개 이상
    if (leftGrades.F3 >= 1 && rightGrades.F3 >= 1) {
      // F4 체크: F4가 좌우에 각 1개 이상
      if (leftGrades.F4 >= 1 && rightGrades.F4 >= 1) {
        // F5 이상은 비율 체크 (1:2 또는 2:1)
        // ... 추가 로직
        return 'F5'; // 또는 더 높은 등급
      }
      return 'F4';
    }
    return 'F3';
  }

  return 'F2';
}

async function collectSubtreeGrades(userId) {
  // DFS로 서브트리의 모든 노드의 등급을 수집
  const grades = { F1: 0, F2: 0, F3: 0, F4: 0, F5: 0, F6: 0, F7: 0, F8: 0 };
  // ... 재귀적으로 서브트리 순회하며 등급 카운트
  return grades;
}
```

## 5. 중요 참고사항

1. **등급은 하위에서 상위로 계산**: 리프 노드부터 시작하여 루트까지 올라가며 계산
2. **서브트리 전체 구조 고려**: 직계 자식의 등급뿐만 아니라 전체 하위 트리의 등급 분포를 확인
3. **F5-F8의 비율 규칙**: 1:2 또는 2:1 비율은 좌우 서브트리의 해당 등급 개수를 의미
4. **관리자는 특별 처리**: 시스템의 최상위 노드로서 특별한 규칙이 적용될 수 있음

## 6. 테스트 시나리오

### 시나리오 1: 3노드 트리
```
    1
   / \
  2   3
```
- 노드 2, 3: F1 (자식 없음)
- 노드 1: F2 (좌우 자식 있음)

### 시나리오 2: 7노드 완전 이진 트리
```
      1
    /   \
   2     3
  / \   / \
 4   5 6   7
```
- 노드 4, 5, 6, 7: F1 (자식 없음)
- 노드 2, 3: F2 (좌우 자식 있음)
- 노드 1: F3 (좌우에 F2가 각 1개씩)

### 시나리오 3: 15노드 완전 이진 트리
```
          1
       /     \
      2       3
    /  \    /  \
   4    5  6    7
  / \  / \/ \  / \
 8  9 10 11 12 13 14 15
```
- 노드 8-15: F1 (8개)
- 노드 4-7: F2 (4개)
- 노드 2, 3: F3 (2개)
- 노드 1: F4 (1개)

## 7. 검증 방법

1. **트리 구조 확인**: 각 노드의 부모-자식 관계가 올바른지 확인
2. **리프 노드부터 계산**: 가장 하위 레벨부터 등급 계산 시작
3. **서브트리 등급 집계**: 각 노드에서 좌우 서브트리의 등급 분포 확인
4. **규칙 적용**: 정의된 규칙에 따라 등급 결정
5. **전체 분포 검증**: 최종 등급 분포가 예상과 일치하는지 확인