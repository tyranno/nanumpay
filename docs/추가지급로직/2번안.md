# 추가지급 로직 2번안

**작성일**: 2024-12-12
**상태**: User.gradeHistory 활용 방안

---

## 1. 핵심 룰 (1번안과 동일)

### 해당 등급으로 몇 개월째인가?

```
┌────────────────────────────────────────────────────────┐
│                                                        │
│  핵심 질문: "이 등급으로 몇 개월째인가?"               │
│                                                        │
│  0개월째 (승급/등록월) → 기본지급                      │
│  1개월째 → 추가1차                                     │
│  2개월째 → 추가2차                                     │
│  ...                                                   │
│  N개월째 → 추가N차 (최대 차수까지)                     │
│                                                        │
└────────────────────────────────────────────────────────┘
```

---

## 2. 기존 데이터 구조 (User.gradeHistory)

### 2.1 스키마 (이미 존재!)

```javascript
// User 모델 (96-106줄)
gradeHistory: [{
  date: Date,                              // 변동일
  fromGrade: String,                       // 이전 등급 (등록 시 null)
  toGrade: String,                         // 변동 후 등급
  type: 'registration' | 'promotion',      // 등록 or 승급
  revenueMonth: String                     // 매출월 (YYYY-MM) ⭐
}]
```

### 2.2 예시 데이터

```javascript
// 7월 등록, 10월 F4 승급한 사용자
user.gradeHistory = [
  {
    date: "2024-07-15",
    fromGrade: null,
    toGrade: "F1",
    type: "registration",
    revenueMonth: "2024-07"
  },
  {
    date: "2024-10-20",
    fromGrade: "F1",
    toGrade: "F4",
    type: "promotion",
    revenueMonth: "2024-10"  // ⭐ 현재 등급 시작월
  }
]
```

### 2.3 Virtual 필드 (이미 존재!)

```javascript
// lastGradeChangeDate (177-183줄)
userSchema.virtual('lastGradeChangeDate').get(function() {
  if (!this.gradeHistory || this.gradeHistory.length === 0) {
    return this.joinedAt || this.createdAt;
  }
  return this.gradeHistory[this.gradeHistory.length - 1].date;
});
```

---

## 3. 2번안 핵심: gradeHistory 활용

### 3.1 현재 등급 시작월 가져오기

```javascript
function getCurrentGradeStartMonth(user) {
  if (!user.gradeHistory || user.gradeHistory.length === 0) {
    return null;
  }
  const lastEntry = user.gradeHistory[user.gradeHistory.length - 1];
  return lastEntry.revenueMonth;  // "2024-10"
}
```

### 3.2 등급 유지 개월 수 계산

```javascript
function getMonthsInCurrentGrade(user, currentMonth) {
  const startMonth = getCurrentGradeStartMonth(user);
  if (!startMonth) return 0;

  return getMonthDiff(currentMonth, startMonth);
  // 예: "2024-12" - "2024-10" = 2
}
```

### 3.3 추가지급 대상 판단

```javascript
function isAdditionalPaymentTarget(user, currentMonth) {
  const monthsInGrade = getMonthsInCurrentGrade(user, currentMonth);
  const maxMonths = MAX_ADDITIONAL_PAYMENTS[user.grade];

  // 0개월 = 승급/등록월 = 기본지급 → 추가지급 대상 아님
  // 1개월 이상 & 최대 차수 이하 = 추가지급 대상
  return monthsInGrade > 0 && monthsInGrade <= maxMonths;
}
```

---

## 4. 탐색 로직 (단순화!)

### 4.1 N월 등록 처리 시

```
N월 등록 처리:
│
├─ 1. 전체 active 사용자 조회 (1회 쿼리)
│     const users = await User.find({ status: 'active' });
│
├─ 2. 제외 대상 확정
│     ├─ N월 승급자 (promoted 배열)
│     └─ N월 등록자 (monthlyReg.registrations)
│
└─ 3. 각 사용자별 추가지급 판단
      │
      FOR EACH user (제외 대상 제외):
        │
        ├─ startMonth = user.gradeHistory 마지막 항목의 revenueMonth
        │
        ├─ monthsInGrade = N월 - startMonth
        │
        ├─ 조건 확인:
        │   ├─ monthsInGrade > 0? (0이면 이번 달 승급/등록)
        │   ├─ monthsInGrade <= MAX_ADDITIONAL_PAYMENTS[grade]?
        │   └─ 이미 N월 추가지급 생성됨? (중복 방지)
        │
        └─ 통과 시 → 추가지급 대상 (차수 = monthsInGrade)
```

### 4.2 코드 예시

```javascript
async function findAdditionalPaymentTargets(promoted, monthlyReg, registrationMonth) {
  const additionalTargets = [];

  // 1. 제외 대상 ID 수집
  const excludeIds = new Set([
    ...promoted.map(p => p.userId),
    ...monthlyReg.registrations.map(r => r.userId)
  ]);

  // 2. 전체 active 사용자 조회 (1회!)
  const users = await User.find({
    status: 'active',
    _id: { $nin: Array.from(excludeIds) }
  });

  // 3. 각 사용자별 판단
  for (const user of users) {
    const lastEntry = user.gradeHistory?.[user.gradeHistory.length - 1];
    if (!lastEntry) continue;

    const startMonth = lastEntry.revenueMonth;
    const monthsInGrade = getMonthDiff(registrationMonth, startMonth);
    const maxMonths = MAX_ADDITIONAL_PAYMENTS[user.grade];

    // 추가지급 대상 조건
    if (monthsInGrade > 0 && monthsInGrade <= maxMonths) {
      // 중복 확인
      const alreadyCreated = await WeeklyPaymentPlans.findOne({
        userId: user._id,
        baseGrade: user.grade,
        revenueMonth: registrationMonth,
        installmentType: 'additional'
      });

      if (!alreadyCreated) {
        additionalTargets.push({
          userId: user._id,
          userName: user.name,
          grade: user.grade,
          추가지급단계: monthsInGrade,
          type: 'additional'
        });
      }
    }
  }

  return additionalTargets;
}
```

---

## 5. 예시: F4, 10월 승급

### 데이터

```javascript
user.grade = "F4"
user.gradeHistory = [
  { revenueMonth: "2024-07", toGrade: "F1", type: "registration" },
  { revenueMonth: "2024-10", toGrade: "F4", type: "promotion" }  // 마지막
]
```

### 월별 처리

| 처리 시점 | startMonth | monthsInGrade | 결과 |
|----------|------------|---------------|------|
| 10월 등록처리 | - | - | 승급자 → 제외 (기본지급) |
| 11월 등록처리 | 2024-10 | 1 | **추가1차** |
| 12월 등록처리 | 2024-10 | 2 | **추가2차** |
| 1월 등록처리 | 2024-10 | 3 | **추가3차** |
| 2월 등록처리 | 2024-10 | 4 | 4 > 3(F4 최대) → 대상 아님 |

---

## 6. 설정값 통일 (1번안과 동일)

```javascript
// constants.js
export const GRADE_LIMITS = { ... };

export const MAX_ADDITIONAL_PAYMENTS = Object.fromEntries(
  Object.entries(GRADE_LIMITS).map(([grade, limits]) => [
    grade,
    Math.floor((limits.maxInstallments - 10) / 10)
  ])
);
```

---

## 7. 장점

1. **빠른 속도**: User 테이블 1회 조회로 끝
2. **단순한 로직**: 날짜 차이 계산만으로 판단
3. **스키마 변경 없음**: 이미 gradeHistory 존재
4. **데이터 일관성**: gradeHistory가 Single Source of Truth
5. **이전 달 조회 불필요**: MonthlyRegistrations 탐색 없음

---

## 8. 고려사항

### 8.1 gradeHistory 데이터 정합성

- 승급/등록 시 gradeHistory가 **반드시** 기록되어야 함
- 기존 데이터 중 gradeHistory가 없는 경우 마이그레이션 필요

### 8.2 중복 확인

- 같은 월에 여러 번 등록 처리되어도 중복 생성 방지
- `WeeklyPaymentPlans`에서 `revenueMonth + userId + grade + installmentType` 확인

---

## 9. 수정 작업 체크리스트

- [ ] `constants.js`: `MAX_ADDITIONAL_PAYMENTS` export 추가 (1번안과 동일)
- [ ] `step3_paymentTargets.js`: `findAdditionalPaymentTargets` 함수 전면 교체
- [ ] 기존 사용자 gradeHistory 데이터 확인/마이그레이션
- [ ] 테스트: 등급별 추가지급 차수 확인
- [ ] 테스트: 성능 비교 (대량 데이터)

---

## 10. 변경 영향 범위

| 파일 | 변경 내용 |
|-----|----------|
| `constants.js` | `MAX_ADDITIONAL_PAYMENTS` export 추가 |
| `step3_paymentTargets.js` | `findAdditionalPaymentTargets` 전면 교체 |
| User 모델 | 없음 (이미 gradeHistory 존재) |

---

## 11. 요약

```
┌────────────────────────────────────────────────────────┐
│                                                        │
│  2번안: User.gradeHistory 활용                         │
│                                                        │
│  1. gradeHistory 마지막 항목 = 현재 등급 시작 정보     │
│  2. startMonth = lastEntry.revenueMonth                │
│  3. monthsInGrade = 현재월 - startMonth                │
│  4. monthsInGrade = 추가지급 차수                      │
│                                                        │
│  → 이전 달 MonthlyRegistrations 탐색 불필요!           │
│  → User 테이블 1회 조회로 끝!                          │
│                                                        │
└────────────────────────────────────────────────────────┘
```
