# MLM 시스템 설계 문서 v6.0

**버전**: 6.0
**작성일**: 2025년 10월 11일
**기준 요구사항**: 시스템_요구사항_검토문서 v4.0

**주요 변경사항 (v6.0)**:
- **동적 지급 계획 생성**: 등록/승급 시 10회만 생성
- **10회 완료 시점 처리**: 금요일 자동처리에서 추가 계획 생성
- **매출월 기준 변경**: 각 10회 완료 시점의 매출월 기준
- **조건 확인 주기**: 매 10회 완료 시점마다 등급/보험 확인

---

## 📋 목차

1. [시스템 개요](#1-시스템-개요)
2. [데이터베이스 설계](#2-데이터베이스-설계)
3. [지급 계획 처리 방안](#3-지급-계획-처리-방안)
4. [자동화 프로세스](#4-자동화-프로세스)
5. [웹 API 설계](#5-웹-api-설계)
6. [데이터 흐름도](#6-데이터-흐름도)

---

## 1. 시스템 개요

### 1.1 핵심 원칙

**v4.0 요구사항 기반 설계 원칙**:

1. **병행 지급**: 승급 시 기존 지급 중단하지 않고 새 지급 추가
2. **동적 계획 생성**: 10회 완료 시점에 추가 10회 계획 생성 ⭐ 신규
3. **매출월 기준**: 각 10회 완료 시점의 매출월로 금액 재계산 ⭐ 신규
4. **조건 확인**: 매 10회 완료 시점마다 등급/보험 확인 ⭐ 신규
5. **주간 집계**: 금요일마다 자동 지급 + 추가 계획 생성

### 1.2 시스템 구성도

```
[용역자 등록]
    ↓
[트리/등급 재계산] ← 영향받는 사용자만
    ↓
[초기 10회 지급계획 생성] ⭐ v6.0: 10회만
    ↓
[주차별 총계 업데이트]
    ↓
[매주 금요일 자동 지급]
    ↓
[10회 완료 확인] ⭐ v6.0 신규
    ↓
[추가 10회 계획 생성] ⭐ v6.0 신규
    ↓
[통계 증분 업데이트]
```

---

## 2. 데이터베이스 설계

### 2.1 컬렉션 개요

전체 **4개 핵심 컬렉션** 구성:

| 컬렉션명 | 목적 | 업데이트 시점 | 조회 빈도 |
|---------|------|--------------|----------|
| **monthlyRegistrations** | 월별 등록/매출 관리 | 용역자 등록 시 | 낮음 |
| **monthlyTreeSnapshots** | 월별 계층도/등급 확정 | 등록 시 + 월말 | 중간 |
| **weeklyPaymentPlans** | 개별 지급 계획 | 등록/승급/10회완료 시 ⭐ | 높음 |
| **weeklyPaymentSummary** | 주차별 총계 (통계) | 등록/지급/10회완료 시 ⭐ | 매우 높음 |

---

### 2.2 컬렉션 상세 설계

#### 2.2.1 monthlyRegistrations (월별 등록 관리)

**목적**: 매월 용역자 등록 및 매출 관리

```javascript
{
  _id: ObjectId,
  monthKey: String,              // "2025-10" (YYYY-MM)

  // 등록 정보
  registrationCount: Number,     // 해당 월 등록 인원
  totalRevenue: Number,          // 총매출 (인원 × 100만원)
  adjustedRevenue: Number,       // 관리자 수동 조정 금액 (null이면 자동)

  // 등록자 목록
  registrations: [{
    userId: String,
    userName: String,
    registrationDate: Date,      // 실제 등록일
    sponsorId: String,           // 후원자
    grade: String,               // 등록 시점 등급 (등급 재계산 후)
    position: String             // 'left' | 'right' | 'root'
  }],

  // 등급별 분포 (월말 기준)
  gradeDistribution: {
    F1: Number,
    F2: Number,
    F3: Number,
    F4: Number,
    F5: Number,
    F6: Number,
    F7: Number,
    F8: Number
  },

  // 등급별 배분 금액 (누적 방식)
  gradePayments: {
    F1: Number,  // 8%
    F2: Number,  // 27%
    F3: Number,  // 42%
    F4: Number,  // 55%
    F5: Number,  // 67%
    F6: Number,  // 78%
    F7: Number,  // 88%
    F8: Number   // 97%
  },

  createdAt: Date,
  updatedAt: Date
}
```

**인덱스:**
- `monthKey` (unique)
- `registrations.userId`

**업데이트 시점:**
- 용역자 등록 시 (등급 재계산 후)

---

#### 2.2.2 weeklyPaymentPlans (개별 지급 계획) ⭐ v6.0 변경

**목적**: 용역자별 10회 단위 지급 계획 관리

```javascript
{
  _id: ObjectId,
  userId: String,
  userName: String,

  // 계획 유형 ⭐ v6.0: generation 추가
  planType: String,              // 'initial' | 'promotion' | 'additional'
  generation: Number,            // 몇 번째 10회인지 (1, 2, 3, ...) ⭐ 신규

  // 기준 정보
  baseGrade: String,             // 계획 생성 시점 등급
  revenueMonth: String,          // 매출 귀속 월 (YYYY-MM)
  startDate: Date,               // 지급 시작일 (첫 금요일)

  // 진행 정보
  totalInstallments: Number,     // 총 할부 횟수 (항상 10) ⭐ v6.0: 10 고정
  completedInstallments: Number, // 완료된 횟수
  planStatus: String,            // 'active' | 'completed' | 'terminated'

  // 할부 상세 (10개) ⭐ v6.0: 항상 10개
  installments: [{
    week: Number,                // 회차 (1~10)
    weekNumber: String,          // ISO 주차 (2025-W31)
    scheduledDate: Date,         // 지급 예정일 (금요일)

    revenueMonth: String,        // 매출 귀속 월
    gradeAtPayment: String,      // 실제 지급 시점 등급 (지급 시 기록)

    baseAmount: Number,          // 기준 금액 (등급별 배분액)
    installmentAmount: Number,   // 회차 지급액 (기준÷10)
    withholdingTax: Number,      // 원천징수세 (3.3%)
    netAmount: Number,           // 실수령액

    status: String,              // 'pending' | 'paid' | 'skipped'
    paidDate: Date,              // 실제 지급일
    insuranceSkipped: Boolean,   // 보험 미가입으로 건너뜀

    installmentType: String      // 'initial' | 'additional' (항상 initial) ⭐
  }],

  // 추가 정보 ⭐ v6.0 신규
  parentPlanId: ObjectId,        // 이전 10회 계획 ID (연결 추적용)
  createdBy: String,             // 'registration' | 'promotion' | 'auto_generation'

  createdAt: Date,
  updatedAt: Date
}
```

**v6.0 주요 변경:**
- `generation`: 몇 번째 10회인지 추적 (1, 2, 3, ...)
- `totalInstallments`: 항상 10으로 고정
- `parentPlanId`: 이전 계획과의 연결 관계
- `createdBy`: 생성 출처 구분

**인덱스:**
- `userId`
- `planType`
- `generation`
- `baseGrade`
- `revenueMonth`
- `planStatus`
- `installments.weekNumber`
- `installments.status`

---

#### 2.2.3 weeklyPaymentSummary (주차별 총계) ⭐ v6.0: 주차별 지급대장 역할

**목적**: 주차별 전체 지급 총계 및 통계 (빠른 조회용) + **주차별 지급대장 관리**

```javascript
{
  _id: ObjectId,
  weekNumber: String,            // ISO 주차 (2025-W31)
  weekDate: Date,                // 해당 금요일 날짜
  monthKey: String,              // 월 키 (2025-08)

  // 지급 총계
  totalAmount: Number,           // 지급 총액
  totalTax: Number,              // 원천징수 총액
  totalNet: Number,              // 실수령 총액
  recipientCount: Number,        // 지급 대상자 수

  // 통계
  status: String,                // 'pending' | 'paid' | 'processing'
  processedAt: Date,             // 처리 완료 시각

  createdAt: Date,
  updatedAt: Date
}
```

**v6.0 핵심 역할:**
1. **주차별 지급대장**: 매주 지급 대상 및 금액 관리
2. **금요일 자동처리 중심**:
   - 지급 처리 후 Summary 업데이트
   - 10회 완료자 찾기
   - 추가 계획 생성 후 Summary 재업데이트
3. **빠른 조회**: 주차별 총계를 WeeklyPaymentPlans 조회 없이 즉시 확인
4. **통계 기반**: 대시보드, 보고서 등에서 사용

**업데이트 시점:**
- 등록/승급 시: 지급 계획 생성 → Summary에 예상 금액 추가
- 금요일 자동처리: 실제 지급 → Summary 업데이트
- 추가 계획 생성: 새 10회 생성 → Summary에 미래 주차 예상 금액 추가

**인덱스:**
- `weekNumber` (unique)
- `weekDate`
- `monthKey`
- `status`

---

## 3. 지급 계획 처리 방안

### 3.1 초기 계획 생성 (등록/승급 시) ⭐ v6.0 변경

#### 3.1.1 등록 시 Initial 계획 생성

**생성 조건:**
- 용역자 신규 등록 시
- 등급 재계산 완료 후

**생성 내용:**
```javascript
{
  planType: 'initial',
  generation: 1,                 // 첫 번째 10회 ⭐
  baseGrade: user.grade,         // 등록 시점 등급
  revenueMonth: '2025-07',       // 등록월
  totalInstallments: 10,         // 10회 고정 ⭐
  installments: [
    {
      week: 1,
      weekNumber: '2025-W31',
      scheduledDate: new Date('2025-08-01'),
      installmentAmount: 24000,  // 등록월 매출 기준
      installmentType: 'initial'
    },
    // ... 10개
  ]
}
```

**매출 기준:**
- 등록월(registrationDate의 YYYY-MM)의 매출
- `monthlyRegistrations`에서 조회

**지급 시작일:**
- 등록일 + 1개월 후 첫 금요일

#### 3.1.2 승급 시 Promotion 계획 생성

**생성 조건:**
- 등급 재계산 후 승급 확인됨
- 기존 계획은 중단하지 않음 (병행 지급)

**생성 내용:**
```javascript
{
  planType: 'promotion',
  generation: 1,                 // 승급 첫 번째 10회 ⭐
  baseGrade: newGrade,           // 승급 후 등급
  revenueMonth: '2025-10',       // 승급 시점 월
  totalInstallments: 10,         // 10회 고정 ⭐
  installments: [
    {
      week: 1,
      weekNumber: '2025-W41',
      scheduledDate: new Date('2025-10-10'),
      installmentAmount: 81000,  // 승급 시점 월 매출 기준
      installmentType: 'initial'
    },
    // ... 10개
  ]
}
```

---

### 3.2 추가 계획 생성 (10회 완료 시) ⭐ v6.0 신규

#### 3.2.1 생성 시점

**금요일 자동처리 중 확인:**
```javascript
// 지급 처리 완료 후
for (const plan of completedPlans) {
  if (plan.completedInstallments === 10) {
    // 10회 완료 감지 ⭐
    await checkAndCreateAdditionalPlan(plan);
  }
}
```

#### 3.2.2 생성 조건 확인

**1단계: 최대 횟수 확인**
```javascript
const MAX_INSTALLMENTS = {
  F1: 20, F2: 30, F3: 40, F4: 40,
  F5: 50, F6: 50, F7: 60, F8: 60
};

// 전체 완료 회차 계산
const totalCompleted = await WeeklyPaymentPlans.aggregate([
  { $match: { userId, planStatus: 'completed' } },
  { $group: { _id: null, total: { $sum: '$totalInstallments' } } }
]);

const maxForGrade = MAX_INSTALLMENTS[currentGrade];
if (totalCompleted >= maxForGrade) {
  // 최대 횟수 도달 - 생성 안 함
  return;
}
```

**2단계: 등급 확인**
```javascript
const currentGrade = user.grade;
const planGrade = plan.baseGrade;

if (currentGrade < planGrade) {
  // 등급 하락 - 생성 안 함
  return;
}
```

**3단계: 보험 확인 (F3 이상)**
```javascript
if (currentGrade >= 'F3') {
  const insurance = user.insuranceSettings;
  if (!insurance || !insurance.maintained) {
    // 보험 미가입/미유지 - 생성 안 함
    return;
  }
}
```

#### 3.2.3 추가 계획 생성

**완료 매출월 계산:**
```javascript
// 10회차 완료 시점의 날짜로 매출월 결정
const lastInstallment = plan.installments[9]; // 10회차
const completionDate = lastInstallment.paidDate || lastInstallment.scheduledDate;
const revenueMonth = `${completionDate.getFullYear()}-${String(completionDate.getMonth() + 1).padStart(2, '0')}`;
```

**생성 내용:**
```javascript
{
  planType: plan.planType,       // 'initial' | 'promotion' 유지
  generation: plan.generation + 1, // 다음 generation ⭐
  baseGrade: currentGrade,       // 현재 등급
  revenueMonth: '2025-10',       // 완료 매출월 ⭐
  totalInstallments: 10,
  parentPlanId: plan._id,        // 이전 계획 연결 ⭐
  createdBy: 'auto_generation',  // 자동 생성 표시 ⭐
  installments: [
    {
      week: 1,                   // 새로운 10회 시작
      weekNumber: '2025-W42',
      scheduledDate: nextFriday, // 다음 금요일
      installmentAmount: newAmount, // 완료 매출월 기준 재계산 ⭐
      installmentType: 'initial'
    },
    // ... 10개
  ]
}
```

**매출 기준:**
- **완료 매출월**의 매출로 금액 재계산
- 등급이 유지/상승했으면 현재 등급의 금액 적용

**예시:**
```
F1 등급 10회 완료 (2025-10-03):
- 완료 매출월: 2025-10
- 2025-10 매출: 5,000,000원
- F1 기준 금액: 400,000원
- 11~20회차: 400,000 ÷ 10 = 40,000원/회 ⭐ (등록 시와 다름)
```

---

### 3.3 병행 지급 관리

#### 3.3.1 병행 지급 시나리오

**시나리오 1: F1 등급 20회 완료 → F2 승급**
```
타임라인:
- 2025-07-01: 등록 (F1)
  → Initial-Gen1 생성 (1~10회, F1 금액)

- 2025-10-03: 10회 완료
  → 등급 확인: F2 승급!
  → Initial-Gen2 생성 (11~20회, F1 금액, 2025-10 매출)
  → Promotion-Gen1 생성 (1~10회, F2 금액, 2025-10 매출)

- 2025-10-10: 지급
  → Initial-Gen2 11회: F1 금액
  → Promotion-Gen1 1회: F2 금액
  → 병행 지급 ⭐

- 2025-12-05: Initial 20회 완료
  → Initial-Gen3 생성? X (F1 최대 20회 도달)
  → Promotion은 계속 진행

- 2026-01-02: Promotion 10회 완료
  → Promotion-Gen2 생성 (11~20회, F2 금액, 2026-01 매출)
```

**시나리오 2: F3 보험 미유지로 중단**
```
타임라인:
- 2025-07-01: 등록 (F3, 보험 가입)
  → Initial-Gen1 생성 (1~10회)

- 2025-10-03: 10회 완료
  → 등급: F3 유지
  → 보험: 미가입 ❌
  → Initial-Gen2 생성 안 함

- 2025-11-01: 보험 재가입
  → 다음 10회 완료 시점에 확인

- 2026-01-05: (다른 계획의) 10회 완료
  → 등급: F3 유지
  → 보험: 가입 중 ✅
  → 추가 계획 생성
```

---

## 4. 자동화 프로세스

### 4.1 금요일 자동 지급 프로세스 ⭐ v6.0 변경

**실행 시점:** 매주 금요일 00:00

**처리 흐름:**

```javascript
async function processFridayPayments() {
  const today = new Date();
  const weekNumber = getISOWeek(today);

  // === 1단계: 지급 처리 ===
  const plans = await WeeklyPaymentPlans.find({
    'installments': {
      $elemMatch: {
        weekNumber: weekNumber,
        status: 'pending'
      }
    }
  });

  for (const plan of plans) {
    // 지급 대상 할부 찾기
    const installment = plan.installments.find(
      inst => inst.weekNumber === weekNumber && inst.status === 'pending'
    );

    // 보험 확인 (F3 이상)
    const user = await User.findOne({ loginId: plan.userId });
    if (user.grade >= 'F3' && !user.insuranceSettings?.maintained) {
      installment.status = 'skipped';
      installment.insuranceSkipped = true;
      continue;
    }

    // 지급 처리
    installment.status = 'paid';
    installment.paidDate = today;
    installment.gradeAtPayment = user.grade;

    plan.completedInstallments++;

    // 계획 완료 확인
    if (plan.completedInstallments === plan.totalInstallments) {
      plan.planStatus = 'completed';
    }

    await plan.save();
  }

  // === 2단계: WeeklyPaymentSummary 업데이트 ===
  await updateWeeklySummary(weekNumber, plans);

  // === 3단계: 10회 완료 확인 및 추가 계획 생성 ⭐ v6.0 신규 ===
  // Summary에서 이번 주에 10회 완료된 계획 찾기
  const completedPlans = plans.filter(p =>
    p.completedInstallments === 10 && p.planStatus === 'completed'
  );

  for (const plan of completedPlans) {
    await checkAndCreateAdditionalPlan(plan);
  }
}

// 추가 계획 생성 로직 ⭐ v6.0 신규
async function checkAndCreateAdditionalPlan(plan) {
  const user = await User.findOne({ loginId: plan.userId });

  // 1. 최대 횟수 확인
  const MAX_INSTALLMENTS = { F1: 20, F2: 30, F3: 40, F4: 40, F5: 50, F6: 50, F7: 60, F8: 60 };
  const totalCompleted = await calculateTotalCompletedInstallments(plan.userId);

  if (totalCompleted >= MAX_INSTALLMENTS[user.grade]) {
    console.log(`[${plan.userId}] 최대 횟수 도달 - 추가 생성 안 함`);
    return;
  }

  // 2. 등급 확인
  if (user.grade < plan.baseGrade) {
    console.log(`[${plan.userId}] 등급 하락 - 추가 생성 안 함`);
    return;
  }

  // 3. 보험 확인 (F3 이상)
  if (user.grade >= 'F3' && !user.insuranceSettings?.maintained) {
    console.log(`[${plan.userId}] 보험 미가입 - 추가 생성 안 함`);
    return;
  }

  // 4. 완료 매출월 계산
  const lastInstallment = plan.installments[9]; // 10회차
  const completionDate = lastInstallment.paidDate || lastInstallment.scheduledDate;
  const revenueMonth = `${completionDate.getFullYear()}-${String(completionDate.getMonth() + 1).padStart(2, '0')}`;

  // 5. 매출 조회 및 금액 계산
  const monthlyReg = await MonthlyRegistrations.findOne({ monthKey: revenueMonth });
  if (!monthlyReg) {
    console.log(`[${plan.userId}] 매출 정보 없음 - 추가 생성 안 함`);
    return;
  }

  const revenue = monthlyReg.getEffectiveRevenue();
  const gradePayments = calculateGradePayments(revenue, monthlyReg.gradeDistribution);
  const baseAmount = gradePayments[user.grade];
  const installmentAmount = Math.floor(baseAmount / 10 / 100) * 100;

  // 6. 추가 10회 계획 생성
  const nextGeneration = plan.generation + 1;
  const startDate = getNextFriday(completionDate);

  const installments = [];
  for (let i = 1; i <= 10; i++) {
    const scheduledDate = new Date(startDate);
    scheduledDate.setDate(scheduledDate.getDate() + (i - 1) * 7);

    installments.push({
      week: i,
      weekNumber: getISOWeek(scheduledDate),
      scheduledDate,
      revenueMonth,
      gradeAtPayment: null,
      baseAmount,
      installmentAmount,
      withholdingTax: Math.round(installmentAmount * 0.033),
      netAmount: installmentAmount - Math.round(installmentAmount * 0.033),
      status: 'pending',
      insuranceSkipped: false,
      installmentType: 'initial'
    });
  }

  // 7. DB 저장
  const newPlan = await WeeklyPaymentPlans.create({
    userId: plan.userId,
    userName: plan.userName,
    planType: plan.planType,
    generation: nextGeneration,
    baseGrade: user.grade,
    revenueMonth,
    startDate,
    totalInstallments: 10,
    completedInstallments: 0,
    planStatus: 'active',
    installments,
    parentPlanId: plan._id,
    createdBy: 'auto_generation'
  });

  console.log(`[${plan.userId}] 추가 계획 생성 완료 - Generation ${nextGeneration}`);

  // 8. 주차별 총계 업데이트
  await updateWeeklyProjections(newPlan, 'add');

  return newPlan;
}
```

---

### 4.2 용역자 등록 프로세스

```javascript
async function processUserRegistration(userIds) {
  // 1. 사용자 정보 조회
  const users = await User.find({ _id: { $in: userIds } });

  // 2. 등급 재계산 (먼저 실행!)
  const gradeChangeResult = await recalculateAllGrades();
  const affectedUsers = gradeChangeResult.changedUsers || [];

  // 3. 등급 재계산 후 users 정보 다시 조회 (최신 등급 반영)
  const updatedUsers = await User.find({ _id: { $in: userIds } });

  // 4. 월별 등록 정보 업데이트 (최신 등급으로)
  await updateMonthlyRegistrations(updatedUsers);

  // 5. 월별 트리 스냅샷 업데이트
  await updateMonthlyTreeSnapshots(updatedUsers, affectedUsers);

  // 6. 지급 계획 처리
  const paymentPlanResults = [];

  // 6-1. 신규 등록자 Initial 계획 생성 (10회만) ⭐
  for (const user of updatedUsers) {
    const plan = await createInitialPaymentPlan(
      user.loginId,
      user.name,
      user.grade,
      user.registrationDate || user.createdAt
    );
    paymentPlanResults.push({ userId: user.loginId, type: 'initial', plan: plan._id });
  }

  // 6-2. 승급자 Promotion 계획 생성 (10회만) ⭐
  const promotedUsers = affectedUsers.filter(u =>
    u.changeType === 'grade_change' && u.oldGrade && u.newGrade && u.oldGrade < u.newGrade
  );

  for (const promoted of promotedUsers) {
    const user = await User.findOne({ loginId: promoted.userId });
    const plan = await createPromotionPaymentPlan(
      user.loginId,
      user.name,
      promoted.newGrade,
      new Date()
    );
    paymentPlanResults.push({ userId: user.loginId, type: 'promotion', plan: plan._id });
  }

  return {
    success: true,
    registeredUsers: updatedUsers.length,
    affectedUsers: affectedUsers.length,
    promotedUsers: promotedUsers.length,
    paymentPlans: paymentPlanResults
  };
}
```

---

## 5. 웹 API 설계

### 5.1 용역비 지급명부 조회 API

#### 5.1.1 단일 주차 조회

**GET** `/api/admin/payment/weekly?year=2025&month=10&week=2`

**응답:**
```json
{
  "success": true,
  "data": {
    "grandTotal": {
      "totalAmount": 105000,
      "totalTax": 3465,
      "totalNet": 101535
    },
    "week": "2025년 10월 2주",
    "weekNumber": "2025-W41",
    "payments": [
      {
        "no": 1,
        "userId": "사장님",
        "userName": "사장님",
        "grade": "F2",
        "actualAmount": 105000,
        "taxAmount": 3465,
        "netAmount": 101535,
        "installments": [
          {
            "planType": "initial",
            "generation": 2,
            "week": 11,
            "revenueMonth": "2025-10",
            "amount": 24000,
            "tax": 792,
            "net": 23208
          },
          {
            "planType": "promotion",
            "generation": 1,
            "week": 1,
            "revenueMonth": "2025-10",
            "amount": 81000,
            "tax": 2673,
            "net": 78327
          }
        ]
      }
    ],
    "pagination": {
      "page": 1,
      "totalPages": 1,
      "totalItems": 3,
      "itemsPerPage": 20
    }
  }
}
```

#### 5.1.2 기간 조회

**GET** `/api/admin/payment/weekly?startYear=2025&startMonth=10&endYear=2025&endMonth=12`

**응답:**
```json
{
  "success": true,
  "data": {
    "grandTotal": {
      "totalAmount": 1050000,
      "totalTax": 34650,
      "totalNet": 1015350
    },
    "period": {
      "start": "2025년 10월",
      "end": "2025년 12월",
      "weekCount": 13
    },
    "weeks": [
      {
        "year": 2025,
        "monthNumber": 10,
        "weekNumber": 1,
        "week": "2025년 10월 1주",
        "payments": [
          {
            "userId": "사장님",
            "userName": "사장님",
            "grade": "F2",
            "actualAmount": 105000,
            "installments": [
              {
                "planType": "initial",
                "generation": 2,
                "week": 11,
                "revenueMonth": "2025-10"
              }
            ]
          }
        ]
      }
    ],
    "payments": [
      {
        "no": 1,
        "userId": "사장님",
        "userName": "사장님",
        "grade": "F2",
        "totalAmount": 1050000,
        "totalTax": 34650,
        "totalNet": 1015350,
        "paymentCount": 26
      }
    ],
    "pagination": {
      "page": 1,
      "totalPages": 1,
      "totalItems": 3,
      "itemsPerPage": 20
    }
  }
}
```

---

## 6. 데이터 흐름도

### 6.1 등록 시 데이터 흐름

```
[엑셀 업로드/개별 등록]
    ↓
[User 생성/저장]
    ↓
[등급 재계산]
    ↓
[MonthlyRegistrations 업데이트]
    - 등록자 정보 추가 (최신 등급)
    - 매출 계산
    - 등급별 배분액 계산
    ↓
[MonthlyTreeSnapshots 업데이트]
    - 트리 구조 스냅샷
    - 등급 분포
    ↓
[WeeklyPaymentPlans 생성] ⭐ 10회만
    - planType: 'initial'
    - generation: 1
    - totalInstallments: 10
    - revenueMonth: 등록월
    ↓
[WeeklyPaymentSummary 업데이트]
    - 주차별 예상 총계 업데이트
```

### 6.2 금요일 자동처리 데이터 흐름 ⭐ v6.0: WeeklyPaymentSummary 중심 관리

```
[스케줄러 실행: 매주 금요일 00:00]
    ↓
[1단계: 해당 주차 지급 대상 조회]
    - WeeklyPaymentPlans에서 weekNumber로 필터링
    - installments.status: 'pending'
    ↓
[1단계: 지급 처리]
    - 보험 확인 (F3 이상)
    - status: 'pending' → 'paid'
    - completedInstallments++
    - planStatus: 완료 시 'completed'
    ↓
[2단계: WeeklyPaymentSummary 업데이트] ⭐ 주차별 지급대장
    - 실제 지급액 집계
    - totalAmount, totalTax, totalNet 업데이트
    - recipientCount 업데이트
    - status: 'paid', processedAt 기록
    ↓
[3단계: 10회 완료 확인] ⭐ v6.0 신규
    - 이번 주 지급된 계획 중
    - completedInstallments === 10?
    - planStatus === 'completed'?
    ↓
[3단계: 추가 계획 생성 조건 확인] ⭐ v6.0 신규
    FOR EACH completedPlan:
      ├─ 최대 횟수 확인 (F1:20, F2:30, ...)
      ├─ 등급 유지/상승 확인
      └─ 보험 유지 확인 (F3 이상)
    ↓
[3단계: 완료 매출월 기준 금액 계산] ⭐ v6.0 신규
    - 10회차 완료일 → revenueMonth (YYYY-MM)
    - MonthlyRegistrations에서 매출 조회
    - 현재 등급 기준 배분액 계산
    - installmentAmount = baseAmount ÷ 10
    ↓
[3단계: 추가 10회 계획 생성] ⭐ v6.0 신규
    - WeeklyPaymentPlans.create({
        generation: N+1,
        revenueMonth: 완료 매출월,
        parentPlanId: 이전 계획 ID,
        createdBy: 'auto_generation',
        totalInstallments: 10
      })
    ↓
[3단계: WeeklyPaymentSummary 재업데이트] ⭐ v6.0 신규
    - 신규 생성된 계획의 미래 주차에
    - 예상 지급액 추가 (incrementPayment)
    - 지급대상자 수 업데이트
    ↓
[완료: 로깅 및 알림]
    - 지급 완료 로그
    - 10회 완료 알림
    - 추가 계획 생성 로그
    - 조건 미충족 알림
```

**핵심 포인트:**
- **WeeklyPaymentSummary**가 주차별 지급대장 역할
- 금요일 처리: **지급 → Summary 업데이트 → 10회 완료 확인 → 추가 계획 생성 → Summary 재업데이트**
- Summary를 통해 매주 지급 대상 및 금액 관리

### 6.3 승급 시 데이터 흐름

```
[등급 재계산]
    ↓
[승급 감지]
    ↓
[기존 계획 확인]
    - 진행 중인 계획 유지 (중단 안 함)
    ↓
[Promotion 계획 생성] ⭐ 10회만
    - planType: 'promotion'
    - generation: 1
    - totalInstallments: 10
    - revenueMonth: 승급 시점 월
    ↓
[병행 지급 시작]
    - 기존 계획 + 신규 계획 동시 진행
```

---

## 7. v5.0 → v6.0 변경사항 요약

| 항목 | v5.0 | v6.0 |
|------|------|------|
| **등록 시 계획 생성** | 최대 횟수 전체 사전 생성 | 10회만 생성 |
| **추가 계획 생성** | 사전 생성 (미래 예측) | 10회 완료 시점에 동적 생성 |
| **매출 기준** | 등록월 매출로 전체 | 각 10회 완료 시점 매출월 |
| **금요일 처리** | 지급만 | 지급 + 10회 완료 확인 + 추가 생성 |
| **조건 확인** | 등록 시 1회 | 매 10회 완료마다 |
| **generation 필드** | 없음 | 추가 (몇 번째 10회인지) |
| **parentPlanId** | 없음 | 추가 (이전 계획 연결) |
| **createdBy** | 없음 | 추가 (생성 출처 구분) |

---

## 8. 구현 우선순위

### Phase 1: 핵심 로직 변경
1. ✅ WeeklyPaymentPlans 스키마 수정 (generation, parentPlanId, createdBy 추가)
2. ✅ createInitialPaymentPlan: 10회만 생성하도록 수정
3. ✅ createPromotionPaymentPlan: 10회만 생성하도록 수정
4. ✅ checkAndCreateAdditionalPlan: 새 함수 구현
5. ✅ processFridayPayments: 10회 완료 확인 로직 추가

### Phase 2: API 및 UI
1. ✅ API 응답에 generation, planType 정보 추가
2. ✅ 지급명부에 generation 표시
3. ✅ 10회 완료 알림 기능

### Phase 3: 모니터링 및 최적화
1. ✅ 추가 계획 생성 로그
2. ✅ 조건 미충족 알림
3. ✅ 성능 최적화

---

**문서 버전 히스토리:**

- v6.0 (2025-10-11): 동적 지급 계획 생성 방식으로 변경
- v5.0 (2025-10-11): 병행 지급 및 추가 지급기간 도입
- v4.0 (2025-09-20): 등급별 최대 수령 횟수 추가
- v3.0 (2025-09-15): 주차별 총계 컬렉션 추가
- v2.0 (2025-09-10): 월별 스냅샷 구조 개선
- v1.0 (2025-09-01): 초기 버전
